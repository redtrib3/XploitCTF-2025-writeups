# Crypto: RSA1000

**Author**: [redtrib3](https://github.com/redtrib3)<br>
**Points**: 250<br>
**Hint(s)**: None<br>
**Flag**: `XPLOIT{tw0_pr1mes_w4lk_int0_a_b4r}`<br>

**Challenge description:**
![Image](https://github.com/user-attachments/assets/8d3ae86e-fdb0-4b54-a395-0bd09e7ce5a5)

## Solve

### Provided information:
```
N = 6739209782663276184635070871151529398007625466501058938574252582636887535497023673733655010972336121284841015071383339168361056670916659555771955001950095847049054648518133505379440077150089410258371519979497904942381000057937721872345162755813742289177922673225018276835993005601845774906942344155997
e = 65537
c = 5383407264973179548447489666434249743608981879724502664788124302373070497592042919710140533116330487179127198942949212305367132470338467051011483689516959955809909887104386198334976366789162579027682350108152206200601787297165055729515233400233067464068707393044086479963112342654837709603577632256653
```
From the Image in description and the Challenge title, you can understand that this has something to do with the RSA bit length.
If you check the bit length of Modulus N using pycryptodome (or any online tool), it returns 1000, which is lesser than the recommended length of 2048 bits.

The vulnerability in the challenge lies in the the fact that the N is factorizable. use any online tool like Factordb to factorise N,
and follow the rsa algorithm to generate the private key (d) and then decrypt the flag (c).


### Solve script:

```python
# pip install pycryptodome factodb-python
from Crypto.Util.number import *
from factordb.factordb import FactorDB

N = 6739209782663276184635070871151529398007625466501058938574252582636887535497023673733655010972336121284841015071383339168361056670916659555771955001950095847049054648518133505379440077150089410258371519979497904942381000057937721872345162755813742289177922673225018276835993005601845774906942344155997
e = 65537
c = 5383407264973179548447489666434249743608981879724502664788124302373070497592042919710140533116330487179127198942949212305367132470338467051011483689516959955809909887104386198334976366789162579027682350108152206200601787297165055729515233400233067464068707393044086479963112342654837709603577632256653

# using factordb api to find factors
# alternatively use factordb.com.
def factorize_number(number) -> list:
    f = FactorDB(number)
    f.connect()
    return f.get_factor_list()

p,q = factorize_number(N)
phi = (p-1)*(q-1)
d = inverse(e,phi)

m = pow(c,d,N)
print(long_to_bytes(m))

```
